---
// Ride statistics component
const { title } = Astro.props;
---

<div class="ride-stats" id="ride-stats">
  {title && (
    <div class="stats-header">
      <h1 class="stats-title">{title}</h1>
    </div>
  )}
  <div class="stats-toggle">
    <button id="toggle-stats-btn" class="stats-toggle-btn" aria-expanded="true">Hide Stats</button>
  </div>
  <div class="stats-container">
    <div class="stat-item" id="photo-video-stat">
      <div class="stat-value" id="photo-count">--</div>
      <div class="stat-label">Photos</div>
      <div class="stat-value" id="video-count">--</div>
      <div class="stat-label">Videos</div>
      <div class="stat-cta" aria-hidden="true">
        <span class="play-pill">
          <span class="play-icon">â–¶</span>
          Slideshow
        </span>
      </div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="elevation-value">--</div>
      <canvas id="elevation-sparkline"></canvas>
      <div class="stat-label">Feet Climbed</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="distance-value">--</div>
      <div class="stat-label">Miles</div>
    </div>
    <div class="stat-item" id="max-speed-stat">
      <div class="stat-value" id="max-speed-value">--</div>
      <div class="stat-label">Max Speed (mph)</div>
    </div>
  </div>
</div>

<script>
  // Wait for GPX data to be loaded
  function updateRideStats() {
    if (window.gpxData && window.gpxData.statistics) {
      const stats = window.gpxData.statistics;

      // Update distance
      document.getElementById('distance-value').textContent = stats.totalDistance.toFixed(1);

      // Update elevation gain
      document.getElementById('elevation-value').textContent = Math.round(stats.totalElevationGain).toLocaleString();

      // Update max speed
      document.getElementById('max-speed-value').textContent = stats.maxSpeed.toFixed(1);

      // Draw elevation sparkline
      drawElevationSparkline();

      // Setup max speed hover functionality
      setupMaxSpeedHover();
    }

    // Update photo/video count regardless of GPX data
    updatePhotoVideoCount();
  }

  // Update photo/video count from manifest data
  function updatePhotoVideoCount() {
    console.log('updatePhotoVideoCount called, photosData:', !!window.photosData);

    // Try to get photos data from window (loaded by PhotoLoader)
    if (window.photosData && window.photosData.photos) {
      const photos = window.photosData.photos; // All photos are already processed by PhotoLoader
      const photoCount = photos.filter(p => p.type === 'image').length;
      const videoCount = photos.filter(p => p.type === 'video').length;

      console.log('Photo data found:', {
        totalPhotos: window.photosData.photos.length,
        processedPhotos: photos.length,
        photoCount,
        videoCount
      });

      const photoCountElement = document.getElementById('photo-count');
      const videoCountElement = document.getElementById('video-count');

      photoCountElement.textContent = photoCount > 0 ? photoCount : '--';
      videoCountElement.textContent = videoCount > 0 ? videoCount : '--';

      console.log('Updated counts - Photos:', photoCountElement.textContent, 'Videos:', videoCountElement.textContent);

      // Setup click handler to show first photo
      setupPhotoVideoClick(photos);
    } else {
      console.log('No photos data available yet');
    }
    // Note: Removed the retry setTimeout here since we have checkForPhotoData() handling retries
  }

  // Setup click handler for photo/video tile
  function setupPhotoVideoClick(photos) {
    const photoVideoStat = document.getElementById('photo-video-stat');
    if (!photoVideoStat || photos.length === 0) return;

    // Remove any existing click listeners to prevent duplicates
    photoVideoStat.replaceWith(photoVideoStat.cloneNode(true));
    const newPhotoVideoStat = document.getElementById('photo-video-stat');

    newPhotoVideoStat.style.cursor = 'pointer';
    newPhotoVideoStat.addEventListener('click', () => {
      console.log('Photo/video tile clicked, photos:', photos.length);

      // Find the first photo (by timestamp if available, otherwise first in list)
      const sortedPhotos = photos.slice().sort((a, b) => {
        if (a.timestamp && b.timestamp) {
          return new Date(a.timestamp) - new Date(b.timestamp);
        }
        return 0;
      });

      const firstPhoto = sortedPhotos[0];
      console.log('First photo:', firstPhoto);

      if (firstPhoto && window.photoCarousel) {
        console.log('Opening photo carousel with', sortedPhotos.length, 'photos');
        window.photoCarousel.open(sortedPhotos, 0);
      } else {
        console.log('Cannot open carousel - firstPhoto:', !!firstPhoto, 'photoCarousel:', !!window.photoCarousel);
      }
    });
  }

  function drawElevationSparkline() {
    if (!window.gpxData || !window.gpxData.trackPoints) return;

    const canvas = document.getElementById('elevation-sparkline');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const trackPoints = window.gpxData.trackPoints;

    // Get elevation data from track points
    const elevations = [];
    const elevationTrackPoints = [];
    trackPoints.forEach(point => {
      if (point.elevation !== null && point.elevation !== undefined) {
        elevations.push(point.elevation * 3.28084); // Convert meters to feet
        elevationTrackPoints.push(point);
      }
    });

    if (elevations.length === 0) return;

    // Sample the data to fit the canvas width (take every nth point for smooth curve)
    const maxPoints = 80; // Maximum points to draw for smooth sparkline
    const step = Math.max(1, Math.floor(elevations.length / maxPoints));
    const sampledElevations = [];
    const sampledTrackPoints = [];
    for (let i = 0; i < elevations.length; i += step) {
      sampledElevations.push(elevations[i]);
      sampledTrackPoints.push(elevationTrackPoints[i]);
    }

    // Store sampled data for hover functionality
    window.sparklineData = {
      elevations: sampledElevations,
      trackPoints: sampledTrackPoints,
      canvas: canvas
    };

    // Set canvas size dynamically based on container width
    const containerWidth = canvas.parentElement.clientWidth - 32; // Account for padding
    const canvasHeight = 30;
    canvas.width = Math.max(containerWidth, 160); // Minimum 160px width
    canvas.height = canvasHeight;

    // Canvas dimensions
    const width = canvas.width;
    const height = canvas.height;
    const padding = 2;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Calculate min/max for scaling
    const minElevation = Math.min(...sampledElevations);
    const maxElevation = Math.max(...sampledElevations);
    const elevationRange = maxElevation - minElevation;

    if (elevationRange === 0) return;

    // Set up drawing style
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Create gradient fill
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');

    // Begin path for line
    ctx.beginPath();

    // Calculate points and draw line
    const points = [];
    sampledElevations.forEach((elevation, index) => {
      const x = padding + (index / (sampledElevations.length - 1)) * (width - 2 * padding);
      const y = height - padding - ((elevation - minElevation) / elevationRange) * (height - 2 * padding);
      points.push({ x, y });

      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    // Draw the line
    ctx.stroke();

    // Fill area under the curve
    ctx.fillStyle = gradient;
    ctx.lineTo(points[points.length - 1].x, height);
    ctx.lineTo(points[0].x, height);
    ctx.closePath();
    ctx.fill();

    // Add hover functionality
    setupSparklineHover(canvas, sampledTrackPoints, width, padding);
  }

  // Setup hover functionality for elevation sparkline
  function setupSparklineHover(canvas, sampledTrackPoints, width, padding) {
    let hoverMarker = null;

    canvas.addEventListener('mouseenter', () => {
      canvas.style.cursor = 'crosshair';
    });

    canvas.addEventListener('mouseleave', () => {
      canvas.style.cursor = 'default';
      // Remove bicycle marker from map
      if (hoverMarker && window.routeMap) {
        window.routeMap.removeLayer(hoverMarker);
        hoverMarker = null;
      }
    });

    canvas.addEventListener('click', (event) => {
      if (!window.routeMap || sampledTrackPoints.length === 0 || !window.L) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;

      // Calculate which track point corresponds to this X position
      const relativeX = (mouseX - padding) / (width - 2 * padding);
      const trackIndex = Math.round(relativeX * (sampledTrackPoints.length - 1));

      if (trackIndex >= 0 && trackIndex < sampledTrackPoints.length) {
        const trackPoint = sampledTrackPoints[trackIndex];
        // Center map on the clicked point and zoom in
        const currentZoom = window.routeMap.getZoom();
        const newZoom = Math.min(currentZoom + 3, 18); // Zoom in 3 levels, max zoom 18
        window.routeMap.setView([trackPoint.lat, trackPoint.lng], newZoom);
      }
    });

    canvas.addEventListener('mousemove', (event) => {
      if (!window.routeMap || sampledTrackPoints.length === 0 || !window.L) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;

      // Calculate which track point corresponds to this X position
      const relativeX = (mouseX - padding) / (width - 2 * padding);
      const trackIndex = Math.round(relativeX * (sampledTrackPoints.length - 1));

      if (trackIndex >= 0 && trackIndex < sampledTrackPoints.length) {
        const trackPoint = sampledTrackPoints[trackIndex];

        // Remove previous marker
        if (hoverMarker) {
          window.routeMap.removeLayer(hoverMarker);
        }

        // Create bicycle icon marker
        const bicycleIcon = window.L.divIcon({
          className: 'bicycle-marker',
          html: `<div class="bicycle-icon">ðŸš´</div>`,
          iconSize: [32, 32],
          iconAnchor: [16, 16]
        });

        // Add new marker at track point location
        hoverMarker = window.L.marker([trackPoint.lat, trackPoint.lng], {
          icon: bicycleIcon,
          zIndexOffset: 1000 // Make sure it appears above other markers
        }).addTo(window.routeMap);
      }
    });
  }

  // Setup hover functionality for max speed stat
  function setupMaxSpeedHover() {
    const maxSpeedStat = document.getElementById('max-speed-stat');
    if (!maxSpeedStat) return;

    maxSpeedStat.addEventListener('mouseenter', () => {
      // Show max speed marker on map
      if (window.maxSpeedMarker && window.routeMap) {
        window.maxSpeedMarker.addTo(window.routeMap);
      }
    });

    maxSpeedStat.addEventListener('mouseleave', () => {
      // Hide max speed marker from map
      if (window.maxSpeedMarker && window.routeMap) {
        window.routeMap.removeLayer(window.maxSpeedMarker);
      }
    });
  }

  // Check for GPX data periodically
  function checkForGpxData() {
    if (window.gpxData && window.gpxData.statistics) {
      updateRideStats();
    } else {
      // Reset display to loading state while waiting
      document.getElementById('distance-value').textContent = '--';
      document.getElementById('elevation-value').textContent = '--';
      document.getElementById('max-speed-value').textContent = '--';
      setTimeout(checkForGpxData, 500);
    }
  }

  // Check for photo data independently
  function checkForPhotoData() {
    updatePhotoVideoCount();
    // Keep checking periodically in case photos load later
    setTimeout(checkForPhotoData, 2000);
  }

  // Start checking when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setupStatsToggle();
      checkForGpxData();
      checkForPhotoData();
    });
  } else {
    setupStatsToggle();
    checkForGpxData();
    checkForPhotoData();
  }

  // Stats show/hide toggle (collapses the stats boxes, leaving only the toggle)
  function setupStatsToggle() {
    const rideStats = document.getElementById('ride-stats');
    const btn = document.getElementById('toggle-stats-btn');
    if (!rideStats || !btn) return;

    const collapsed = localStorage.getItem('statsCollapsed') === '1';
    applyStatsCollapsed(collapsed);

    btn.addEventListener('click', () => {
      const isCollapsed = rideStats.classList.contains('collapsed');
      applyStatsCollapsed(!isCollapsed);
    });

    function applyStatsCollapsed(shouldCollapse) {
      if (shouldCollapse) {
        rideStats.classList.add('collapsed');
        btn.textContent = 'Show Stats';
        btn.setAttribute('aria-expanded', 'false');
        localStorage.setItem('statsCollapsed', '1');
      } else {
        rideStats.classList.remove('collapsed');
        btn.textContent = 'Hide Stats';
        btn.setAttribute('aria-expanded', 'true');
        localStorage.removeItem('statsCollapsed');
      }
      // Recalculate map height/size after layout changes
      setTimeout(() => {
        try {
          window.dispatchEvent(new Event('resize'));
          if (window.routeMap) {
            window.routeMap.invalidateSize();
            if (window.routeBounds) {
              window.routeMap.fitBounds(window.routeBounds, { padding: [20, 20] });
            }
          }
        } catch (_) {}
      }, 60);
    }
  }
</script>

<style>
  .ride-stats {
    margin: 0.5rem 0 2rem 0;
    background: transparent;
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    backdrop-filter: blur(6px);
  }

  .stats-toggle {
    display: flex;
    justify-content: flex-end;
    margin-bottom: 0.5rem;
  }

  .stats-toggle-btn {
    background: transparent;
    border: none;
    color: #2563eb;
    font-weight: 600;
    cursor: pointer;
    text-decoration: underline;
    padding: 4px 6px;
    border-radius: 6px;
  }

  .stats-toggle-btn:hover {
    color: #1e40af;
    text-decoration-thickness: 2px;
  }

  .stats-header {
    text-align: center;
    margin-bottom: 1.5rem;
  }

  .stats-title {
    font-size: 1.7rem;
    font-weight: 900;
    color: #000000;
    margin: 0;
    padding: 1rem 2rem;
    background: transparent;
    border-radius: 12px;
    display: inline-block;
    /* Subtle dark shadow for readability without white outline artifacts */
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
  }

  .stats-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 1rem;
  }

  /* Collapse only the boxes (keep title + toggle visible) */
  .ride-stats.collapsed .stats-container {
    display: none;
  }

  .stat-item {
    text-align: center;
    padding: 0.5rem;
    background: linear-gradient(135deg, #1e40af, #2563eb);
    border-radius: 10px;
    color: white;
    transition: transform 0.3s ease;
    display: flex;
    flex-direction: column;
    justify-content: center;
    min-height: 75px;
    border: none;
  }

  .stat-item:hover {
    transform: translateY(-2px);
  }

  /* Special hover styling for max speed stat to indicate it's interactive */
  #max-speed-stat {
    cursor: pointer;
  }

  #max-speed-stat:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 6px 20px rgba(239, 68, 68, 0.3);
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    line-height: 1;
    margin-bottom: 0.125rem;
    background: linear-gradient(45deg, #fff, #f0f8ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }

  /* Sparkline styling for elevation tile */
  #elevation-sparkline {
    margin: 0.5rem 0;
    border-radius: 4px;
    opacity: 0.9;
    width: 100%;
    height: 30px;
    max-width: 100%;
  }

  /* Photo/video tile specific styling */
  #photo-video-stat {
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  #photo-video-stat:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
  }

  /* Click cue for photo/video tile */
  .stat-cta {
    margin-top: 0.35rem;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .play-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    font-weight: 600;
    color: #10b981;
    background: rgba(16, 185, 129, 0.12);
    border: 1px solid rgba(16, 185, 129, 0.35);
    border-radius: 999px;
    padding: 4px 10px;
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.0);
    animation: pulse-ring 1.8s ease-in-out infinite;
  }

  .play-icon {
    display: inline-block;
    font-size: 0.8rem;
    line-height: 1;
    transform: translateX(0);
    transition: transform 200ms ease;
  }

  #photo-video-stat:hover .play-icon {
    transform: translateX(2px);
  }

  @keyframes pulse-ring {
    0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.0); }
    40% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.14); }
    100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.0); }
  }


  .stat-label {
    font-size: 0.8rem;
    font-weight: 500;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  @media (max-width: 768px) {
    .ride-stats {
      margin: 1rem 0;
      padding: 1rem;
    }

    .stats-container {
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }

    .stat-item {
      padding: 0.75rem;
    }

    .stat-value {
      font-size: 2rem;
    }


    .stat-label {
      font-size: 0.8rem;
    }

    .stats-title {
      font-size: 1.2rem;
      padding: 0.75rem 1.5rem;
    }
  }

  @media (max-width: 480px) {
    .stats-container {
      grid-template-columns: 1fr;
    }
  }
</style>

<style is:global>
  .bicycle-marker {
    background: none !important;
    border: none !important;
  }

  .bicycle-icon {
    background: rgba(59, 130, 246, 0.95);
    border: 2px solid white;
    border-radius: 50%;
    padding: 4px;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    cursor: crosshair;
    transition: all 0.2s ease;
    width: 32px;
    height: 32px;
  }

  .bicycle-icon:hover {
    background: rgba(59, 130, 246, 1);
    transform: scale(1.1);
  }
</style>
